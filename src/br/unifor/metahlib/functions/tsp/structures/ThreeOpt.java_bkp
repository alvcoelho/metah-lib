package br.unifor.metahlib.functions.tsp.structures;

import java.util.ArrayList;
import java.util.List;

import br.unifor.metahlib.base.Function;
import br.unifor.metahlib.base.NeighbourhoodStructure;

public class CopyOfThreeOpt implements NeighbourhoodStructure {

	public Function function;
	
	public CopyOfThreeOpt(Function function){
		super();
		this.function = function;
	}
	
	@Override
	public List<double[]> getNeighbours(List<double[]> parents) {
		
		TwoOpt two_opt1 = new TwoOpt();
		TwoOpt two_opt2_1 = new TwoOpt();
		TwoOpt two_opt2_2 = new TwoOpt();
		
		List<double[]> c = two_opt1.getNeighbours(parents, 2, 4);
		
		System.out.print("C: [");
		//BUG!!
//		for(Double d : c.get(0)){
		double[] x = c.get(0);
		for(Double d : x){
			System.out.print(d + ",");
		}
		System.out.print("]");
		
		System.out.println();
		
		double[] child1 = two_opt2_1.getNeighbours(c, two_opt1.getEdge1(), -1).get(0);
		double[] child2 = two_opt2_2.getNeighbours(c, -1, two_opt1.getEdge2()).get(0);
		
		List<double[]> resultChild = new ArrayList<double[]>();
		
		System.out.print("Child 1: [");
		for(Double d : child1){
			System.out.print(d + ",");
		}
		System.out.print("]");
		
		System.out.println();
		
		System.out.print("Child 2: [");
		for(Double d : child2){
			System.out.print(d + ",");
		}
		System.out.print("]");
		
		if(function.eval(child1) > function.eval(child2)){
			resultChild.add(child1);
		} else {
			resultChild.add(child2);
		}
		
		return resultChild;
	}

	public static void main(String[] args) {
		List<double[]> parents = new ArrayList<double[]>();
		parents.add(new double[]{1,2,3,4,5,6,7,8});
		
		CopyOfThreeOpt t = new CopyOfThreeOpt(null);
		t.getNeighbours(parents);
	}
	
}
